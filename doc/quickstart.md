Quick start guide
=================

In this quick start guide, we will see how you can use TDBM to query, read and write data to your database
We will assume that you successfully installed TDBM using Mouf, and therefore, that TDBM is connected
to your database and that the TDBM DAOs have been generated. You can learn more about DAO generation in the
<a href="generating_daos.md">Generating DAOs guide</a>.

Our playground data model
-------------------------

For this tutorial, let's assume a very classic database schema for handling users.

- We have users. Users can be part of several groups, and obviously, a group can contain several users.
- A group has a name.
- A user has a name and is part of a country.

<img src="images/schema1.png" alt="database schema" />

Connecting to the database
--------------------------

When you install TDBM in Mouf, you will be asked the connection to your database. This connection will be represented by a
`dbalConnection` instance. This instance represents a pointer to your database and can be used to execute SQL queries.
But we won't be using the `dbalConnection` instance. Indeed, the whole point of TDBM is to avoid writing SQL.

Upon installation, TDBM will propose you to generate the DAOs (Data Access Objects). DAOs are classes that will help you access
the objects in your database. There is one DAO per table in your database. Each DAO will return "beans". Each row in your database
will be represented by one instance of a bean.

Usage sample
------------

Let's now review a few samples:

###Creating a new row in the "users" table:

```php
// Create a new bean
// Be default, you MUST pass to the bean constructor the list of all columns that are not nullable.
$userBean = new User("myName");

// Fill the remaining (nullable) columns of the bean using the setters
$userBean->setPassword(password_hash("myPassword", PASSWORD_DEFAULT));
$userBean->setMail("me@mail.com");
// Any date should be passed as a PHP DateTime or DateTimeImmutable
$userBean->setCreateDate(new DateTimeImmutable());

// Finally, let's save this bean.
// For this, we need an instance of the DAO.
// The $userDao will be typically returned by the container of your application.
$userDao->save($userBean);
```

Since we have a "users" table, TDBM generated
a `UserDao` class and a `UserBean` class. `UserDao` can be used to to create/update/delete/search any
user.

You can also notice that the "save()" method is not called on the `UserDao`, not on the `UserBean`.

###Retrieving a user bean by its primary key:

```php
// Let's get the bean
$userBean = $userDao->getById(42);

// Let's display the name
echo $userBean->getName();
```

TDBM will automatically detect the primary key of your table (of course, your table must have a primary key). There is
no name convention to respect, your primary key column can be named anything ('id', 'userid', 'isuser', ...)

To use this method, the primary key must be on a single column. If your primary key is on several columns, you can still use the
search method (see below).


###Querying the database

Now, what about getting the list of all users and displaying their name?

Ok, that's easy, just use the `getUserList()` method!

```php
// Let's get the list of users
$userList = $userDao->getList();

// Let's display the names
foreach ($userList as $userBean) {
	/* @var $userBean UserBean */
	echo $userBean->getName()."<br/>";
}
```

In our example, we would see

```
John Doe
Jean Dupont
Robert Marley
Bill Shakespeare
```


The `getList` method will return the list of beans.
Of course, most of the time, you don't want all the rows in a database.
You want to perform a query with filters.


###Querying the database with filters

Now, what if I want to get something more difficult, like the list of users with name starting with a 'J'?

To do this, I need to call the `getListByFilter` method and pass the filter in parameter.

At this point, it might be a good idea to have a look at the code TDBM did generate. For the `users` table, TDBM
generated 4 classes:

- `UserBaseDao`: the base class that contains methods to access the "users" table. It is generated by TDBM. You should
  never modify this class.
- `UserDao`: this class extends `UserBaseDao`. If you have some custom requests, you should perform them in this class. You can
  edit it as TDBM will never overwrite it.
- `UserBaseBean`: the bean mapping the columns of the "users" table. This class contains getters and setters for each and every
  column of the "users" table. It is generated by TDBM and you should never modify this class.
- `UserBean`: this class extends `UserBaseBean`. If you have some custom getters and setters, you should implement them in this class. You can
  edit it as TDBM will never overwrite it.


In our example, we want to perform a query that retrieves any name starting with a "J". This is a new
kind of query. Since any request should be part of a DAO, we will add this request to the `UserDao`.
 
Therefore, our code will be:

```php
class UserDao extends UserBaseDao {

	/**
	 * Returns the list of users starting with $firstLetter
	 *
	 * @param string $firstLetter
	 * @return array&lt;UserBean>
	 */
	public function getUsersByLetter($firstLetter) {
		// The getListByFilter can be used to retrieve a list of UserBean
		// It takes in parameter a SQL filter string and a list of parameters.
		return $this->getListByFilter("name LIKE :name", [ "name" => $firstLetter.'%' ]);
	}
}
```

And you can simply use it like this: 

```php
$userDao = Mouf::getUserDao();

$users = $userDao->getUsersByLetter("J");
foreach ($users as $userBean)
{
	/* @var $userBean UserBean */
	echo $userBean->getName().'&lt;br/>';
}
```

You can learn much more about filters in the [advanced section](advanced.md) of this documentation.

<div class="alert"><strong>Very important</strong>: NEVER ever append dynamically parameters in the filter string. Use parameterized queries instead.<div>

You should never write something like:

```php
// NEVER DO THIS!
$list = $this->getListByFilter("name LIKE '".$firstLetter.'%"' );
```

<div class="alert alert-info">First of all, be writing this, you are introducing a security flaw in your application (namely: an SQL injection).
Furthermore, TDBM performs a very complex analysis on your SQL query. It takes a lot of time. Hopefully, it is cached,
so the cost of the analysis will be negligible in the long run. But if you append parameters in the SQL query instead
of using parameters, TDBM will not be able to find the query in the cache. The cache will grow with useless queries 
while your application will be very slow. You have been warned!</div>

So far, so good, we have had enough play with the `Users` table. But the users table is not alone and it would be good to get some more information.

Navigating the object model
---------------------------

###Many to one relationships

![Users and countries](images/users_countries.png)

So what if I want to get the name of the country in which the first user is located?

```php
// Let's get the user bean
$userBean = $userDao->getById(1);

// Let's get the country bean
$countryBean = $userBean->getCountry();

// Let's display the country name
echo $countryBean->getName();
```

Notice how you can jump from the _userBean_ to the _countryBean_ using the `getCountry` method.
The user table has a *country_id* column that points (through a foreign key) to the `countries` table, so it has a `getCountry` method!

Of course, there is also a setter:

```php
$userBean->setCountry($countryBean);
```

Notice how you set an object rather than an ID.

###One to many relationships

Ok. What, now, if I want to find a list of users from a particular country?

That's easy too.

```php
// Let's get the country bean
$countryBean = $countryDao->getById(1);

// Let's get the users from that country
$userBeans = $countryBean->getUsers();
```

###Many to many relationships

![Users and roles](images/users_roles.png)

TDBM can automatically detect pivot tables in your data model.
Pivot tables will have no DAO and no Beans associated. Instead, TDBM will generate a complete list of methods in the beans
to edit them.

```php
// Getter
$rolesBean = $userBean->getRoles();

// Adder
$userBean->addRole($roleBean);

// Remover
$userBean->removeRole($roleBean);

// Remover
$hasRole = $userBean->hasRole($roleBean);
```

Unlike in Doctrine, TDBM does not need to have a notion of *owning* and *inverse* side of a many to many relationship.
Many to many relationships are symmetrical. Therefore, you will find the same methods in the `RoleBean` class:

```php
// Getter
$usersBean = $roleBean->getUsers();

// Adder
$userBean->addUser($roleBean);

// Remover
$userBean->removeUser($roleBean);

// Remover
$hasUser = $roleBean->hasUser($roleBean);
```


Joins ans filters
-----------------

In the previous chapter, we saw how to apply filters on a table (for instance to get all users whose name starts with a 
'J'). In this chapter, we will see how to apply JOINs in the filters.

In the example below, we will perform a query to get all users living in a country whose name starts by a given letter.


```php
class UserDao extends UserBaseDao {
	/**
	 * Returns the list of users whose country name starts by "$countryName"
	 *
	 * @param string $countryName
	 * @return UserBean[]
	 */
	public function getUsersByCountryName($countryName) {
		// Behold the magic!
		return $this->getListByFilter("country.name LIKE :country", [ 'country' => $countryName.'%' ] );
	}
}
```

Here, we called the `getListByFilter` method passing a filter on the `name` column of the `country` table.

Behind the scene, TDBM is calling a library called [MagicQuery](http://mouf-php.com/packages/mouf/magic-query/README.md).
MagicQuery is smart enough to automatically detect the link between the `users` and the `countries` table. You just need
to tell TDBM what filter you want on **any column** in **any table** in your database model and TDBM will find
the right query for you.

Most of the time, of course, you will not pass the name of the country but the ID of the country. Actually,
using TDBM you can just pass the object. Have a look!

TODO: check this!

<pre class="brush:php">
class UserDao extends UserBaseDao {
	/**
	 * Returns the list of users whose country is "$countryBean"
	 *
	 * @param CountryBean $countryBean
	 * @return array&lt;UserBean>
	 */
	public function getUsersByCountry(CountryBean $countryBean) {
		// You can pass a CountryBean instance directly to the getUserListByFilter method!
		return $this->getUserListByFilter($countryBean);
	}
}
</pre>

You would use this method like this:

<pre class="brush:php">
// Let's get the DAO
$countryDao = Mouf::getCountryDao();
$userDao = Mouf::getUserDao();

// Let's get the country bean
$countryBean = $countryDao->getCountryById(12);

// Let's get the users from this country
$userList = $userBean->getUsersByCountry($countryBean);

// Let's display the list of users in this country
foreach ($userList as $userBean)
{
	/* @var $userBean UserBean */
	echo $userBean->getName().'&lt;br/>';
}
</pre>

So now, what if I want to find out what groups robert marley belongs to.<br/>
We saw how to access a "1*" and "*1" relationship, therefore, we could do it by getting "robert marley" from users, then accessing the "pivot_users_groups" objects, then accessing the "groups" objects associated to that group. But this would be definitely tedious, and the use of a pivot table to generate "**" relationships is definitely common.<br/>
Hopefully, TDBM can help here too:

<pre class="brush:php">
// Since we are accessing groups, we will modify the GroupDao class
class GroupDao extends GroupDaoBase {
	/**
	 * Returns the list of groups associated to a user
	 *
	 * @param UserBean $userBean
	 * @return array&lt;UserBean>
	 */
	public function getGroupsForUser(UserBean $userBean) {
		// Behold the magic!
		return $this->getCountryListByFilter($userBean);
	}
}
</pre>

Powerful, isn't it? TDBM automatically detected the pivot table and performed the SQL double join to retrieve the groups our user belongs too.<br/>
<br/>
Actually, TDBM is much more powerful. It can perform any kind of joins between 2 tables as long as they can be related by a constraint. Let's admit that I want to find the countries of all the writers in database. Well, I can do it in one single line of code:<br/>
<br/>

<pre class="brush:php">
return $this->getCountryListByFilter(new EqualFilter("groups", "name", "writers"));
</pre>

Let's now learn how to <a href="generating_daos.md">regenerate DAOs</a> when your data model changes.